'use strict';

/**
 * Locates all occurances of given `token` which are not escaped (e.g. are not
 * preceded with `\`) given in `str`
 * @param  {String} str
 * @return {Array}  Array of token ranges
 */
export function findUnescapedTokens(str, token) {
    const result = new Set();
    const tlen = token.length;

    // 1. Find all occurances of tokens
    let pos = 0;
    while ((pos = str.indexOf(token, pos)) !== -1) {
        result.add(pos);
        pos += tlen;
    }

    if (result.size) {
        // 2. Remove ones that escaped
        let pos = 0;
        const len = str.length;

        while (pos < len) {
            if (str[pos++] === '\\') {
                result.delete(pos++);
            }
        }
    }

    return Array.from(result).map(ix => range(ix, tlen));
}

/**
 * Replaces `ranges`, generated by `range()` function, with given `value` in `str`
 * @param  {String} str    Where to replace ranges
 * @param  {Array} ranges Ranes, created by `range()` function
 * @param  {String|Function} value  Replacement value. If itâ€™s a function, it
 * will take a range value as argument and should return a new string
 * @return {String}
 */
export function replaceRanges(str, ranges, value) {
	// should walk from the end of array to keep ranges valid after replacement
	for (let i = ranges.length - 1; i >= 0; i--) {
		const r = ranges[i];

        let offset = 0;
        let offsetLength = 0;
        let descendingOrder = false;

        if (str.substr(r[0] + r[1], 1) === '@'){
            if (str.substr(r[0] + r[1] + 1, 1) === '-') {
                descendingOrder = true;
            } 
            const matches = str.substr(r[0] + r[1] + 1 + Number(descendingOrder)).match(/^(\d+)/);
            if (matches) {
                offsetLength = matches[1].length + 1 + Number(descendingOrder);
                offset = parseInt(matches[1]) - 1;
            } else {
                offsetLength = 2;
            }
        }

		str = str.substring(0, r[0])
			+ (typeof value === 'function' ? value(str.substr(r[0], r[1]), offset, descendingOrder) : value)
			+ str.substring(r[0] + r[1] + offsetLength);
	}

	return str;
}

export function range(start, length) {
    return [start, length];
}
